#+TITLE: Prusa Telemetry System Architecture
#+AUTHOR: System Documentation
#+DATE: Generated

* System Overview

The Prusa Telemetry system is a real-time monitoring and visualization platform for 3D printer telemetry data. It consists of a Clojure backend that receives UDP telemetry packets and a ClojureScript frontend that displays the data in a web browser.

** Key Features
- Real-time UDP telemetry packet reception and parsing
- WebSocket streaming to multiple frontend clients
- Automatic persistence of print telemetry to disk (EDN format)
- Client-side state persistence via localStorage
- Multiple view modes: Latest Values, Packets, Timeline
- Timeline scrubbing and playback for historical data

** Technology Stack
- Backend: Clojure (JVM) with Aleph (HTTP/WebSocket/UDP), Manifold (streams)
- Frontend: ClojureScript compiled to JavaScript, Reagent (React-like)
- Build Tool: shadow-cljs
- Development: Calva (VS Code), REPL-driven development

* Architecture Layers

** Backend Layer (JVM)

The backend consists of two main components:

*** Telemetry Server (aeonik.prusa-telemetry)
- Receives UDP packets on port 8514 (configurable)
- Parses raw telemetry data into structured Clojure maps
- Applies transducer pipeline for sorting, formatting, and display preparation
- Provides processed stream via Manifold streams

*** Web Server (aeonik.web-server)
- HTTP server on port 8080 (configurable)
- WebSocket endpoint at /ws for real-time data streaming
- Serves static HTML files (index.html, timeline.html)
- Manages print lifecycle tracking and file persistence
- Single consumer for packet saving (prevents duplicate writes)

** Frontend Layer (Browser)

The frontend is a single-page application with multiple views:

*** Application Entry (aeonik.app)
- Initializes application on page load
- Loads persisted state from localStorage
- Sets up WebSocket connection
- Configures UI controls (pause, clear, view toggle)

*** State Management (aeonik.state)
- Single source of truth: =:telemetry-events= vector
- Derived views: latest values, packets, timeline data
- Auto-save to localStorage (debounced, 4MB limit)
- State persistence across page refreshes

*** Event System (aeonik.events)
- Centralized event dispatch
- Handles WebSocket messages, UI interactions, timeline controls
- Pure functions for state transformations

*** Views (aeonik.views)
- Latest Values View: Shows most recent value for each metric
- Packets View: Shows recent telemetry packets with all metrics
- Timeline View: Time-based scrubbing and playback

*** Timeline (aeonik.timeline)
- Playback loop (100ms steps)
- Automatic start/stop based on state
- Watches state changes to update loop

* Data Flow

** Backend Data Flow

#+BEGIN_SRC
UDP Packet (Raw Text)
    ↓
[UDP Socket] (aleph.udp)
    ↓
parse-packet (parse-prelude, parse-metric-line)
    ↓
[parsed-stream] (Manifold stream, buffer: 100 items)
    ↓
Transducer Pipeline:
  - sort-metrics-xf (sort by device-time-us)
  - add-formatted-time-xf (add formatted timestamps)
  - format-for-display-xf (create display lines)
    ↓
[processed-stream] (Manifold stream, buffer: 200,000 items default, configurable)
    ↓
    ├─→ [saving-stream] (buffer: 100 items)
    │   └─→ [Single Consumer] handle-packet-saving!
    │       ├─→ Detect print_filename
    │       ├─→ Track active prints (sticky, 10min timeout)
    │       └─→ save-packet-to-file! (append-only EDN)
    │
    ├─→ [tap-parsed] (buffer: 100 items, for REPL inspection)
    │   └─→ [packet-buffer-parsed] (max 100 packets)
    │
    ├─→ [tap-processed] (buffer: 100 items, for REPL inspection)
    │   └─→ [packet-buffer-processed] (max 100 packets)
    │
    └─→ [WebSocket Handler] (per client)
        ├─→ [client-stream] (buffer: 100 items per client)
        ├─→ telemetry-to-json (convert to JSON)
        └─→ Stream to browser via WebSocket

Alternative: Metric Stream (time-ordered metrics)
[parsed-stream] → [subscription-stream] (buffer: 100 items)
    ↓
[create-metric-stream] (packet buffer: 2 packets, allows growth)
    ↓
[metric-stream] (buffer: 100 items)
    ↓
    ├─→ [metric-buffer] (max 100 metrics, for REPL inspection)
    └─→ Time-ordered metric consumers
#+END_SRC

** Frontend Data Flow

#+BEGIN_SRC
WebSocket Message (JSON)
    ↓
ws/parse-ws-message
    ↓
events/handle-ws-message
    ├─→ Extract print_filename, packet-msg, received-at
    ├─→ events/create-events (one event per metric)
    ├─→ Sort events by device-time-us
    └─→ merge-sorted-events (O(n+m) merge into :telemetry-events)
    ↓
state/app-state (atom)
    ↓
    ├─→ state/get-latest-values (derived view)
    │   └→ Latest View
    │
    ├─→ state/get-telemetry-packets (derived view)
    │   └→ Packets View (grouped by sender/wall-time-str)
    │
    └─→ state/get-timeline-data (derived view, cached)
        └→ Timeline View
            ├─→ Groups by print_filename
            ├─→ Groups packets by packet-msg
            ├─→ Timeline scrubbing (by packet msg number)
            └─→ Timeline playback (steps by packet msg)

File Loading Flow:
files/fetch-available-files!
    ↓
GET /api/telemetry-files
    ↓
events/:files/set-available
    ↓
User selects file
    ↓
files/load-telemetry-file
    ↓
GET /api/telemetry-file/<date>/<filename>
    ↓
events/:data/load-file
    ↓
events/load-telemetry-packets (batched for large files)
    ↓
events/packets-to-events
    ↓
merge-sorted-events into :telemetry-events
#+END_SRC

** State Persistence Flow

#+BEGIN_SRC
Frontend State Changes
    ↓
add-watch on app-state
    ↓
schedule-save! (debounced, 1 second)
    ↓
save-state-to-storage!
    ├─→ Extract persistable state (:selected-time, :selected-filename, :view-mode)
    └─→ Save to localStorage (JSON, small UI preferences only)
    ↓
Page Refresh
    ↓
load-state-from-storage!
    ├─→ Load from localStorage
    ├─→ Merge with defaults
    └─→ Restore UI preferences (NOT :telemetry-events)

Note: :telemetry-events are NOT persisted. They must be reloaded from server files.
#+END_SRC

* Component Details

** Backend Components

*** aeonik.prusa-telemetry

Core telemetry parsing and processing.

**** Key Functions

- =start-telemetry-server= :: Creates UDP socket and stream pipeline
  - Options: =:port= (default 8514), =:processed-buffer-size= (default 200000)
  - Large processed buffer default handles days-long prints before archiving
- =parse-packet= :: Parses raw UDP message into structured data
- =parse-metric-line= :: Parses individual metric lines (numeric, error, structured)
- =parse-value= :: Tolerant value parsing (long, double, string)

**** Transducers

- =sort-metrics-xf= :: Sorts metrics by device-time-us
- =add-formatted-time-xf= :: Adds formatted timestamps (wall-time-str, device-time-str)
- =format-for-display-xf= :: Creates display-lines for console output

**** Streams

- =socket= :: Raw UDP socket (aleph.udp)
- =parsed-stream= :: Parsed packets (before transducers, buffer: 100 items)
- =processed-stream= :: Fully processed packets (after transducers, buffer: 200,000 items default, configurable)
  - Large buffer prevents packet loss during days-long prints
  - Configurable via =:processed-buffer-size= option
- =create-metric-stream= :: Creates time-ordered metric stream (packet buffer: 2 packets, metric stream buffer: 100 items)

*** aeonik.web-server

HTTP/WebSocket server and file persistence.

**** Key Functions

- =start-web-server= :: Starts HTTP server and sets up consumers
- =websocket-handler= :: Handles WebSocket connections (one per client)
- =handle-packet-saving!= :: Single consumer for file saving (runs once per packet)
- =telemetry-to-json= :: Converts packet to JSON-serializable format
- =save-packet-to-file!= :: Appends packet to EDN file (append-only, one per line)

**** Print Lifecycle Tracking

- =active-prints= :: Atom tracking active prints per sender
  - Format: ={sender {:filename "...", :last-packet-time <timestamp>}}=
- =get-active-print-filename= :: Gets active print with timeout check (10 minutes)
- =set-active-print-filename!= :: Updates active print tracking
- =get-print-filename= :: Extracts print_filename from metrics

**** Streams

- =saving-stream= :: Subscription stream for packet saving (buffer: 100 items)
- =client-stream= :: Per-WebSocket-client subscription stream (buffer: 100 items per client)

**** File Persistence

- Directory structure: =telemetry-data/prints/YYYY-MM-DD/<sanitized-filename>.edn=
- Format: Append-only EDN (one packet per line)
- Each packet is a complete EDN map (JSON-serializable format)

** Frontend Components

*** aeonik.app

Application entry point and initialization.

**** Key Functions

- =init= :: Main initialization function
  - Loads UI preferences from localStorage
  - Ensures timeline selection is set (if data exists)
  - Initializes timeline module
  - Connects WebSocket
  - Fetches available telemetry files from server
  - Sets view mode to :timeline if on /timeline path
  - Performs initial render

- =set-view-mode= :: Called from timeline.html to set view mode

*** aeonik.state

Central state management and persistence.

**** State Structure

#+BEGIN_SRC clojure
{:telemetry-events   []           ; Single vector of all events (sorted by device-time-us)
 :available-files    []           ; Available telemetry files from disk
 :view-mode          :latest      ; :latest | :packets | :timeline
 :selected-packet-msg nil         ; Selected packet msg number for timeline scrubbing
 :selected-filename  nil          ; Selected file identifier (format: "date:filename")
 :timeline-playing   false}       ; Timeline auto-play state
#+END_SRC

Note: WebSocket connection and other transient state are not stored in app-state.

**** Derived View Functions

- =get-latest-values= :: Latest value for each sender/metric pair
- =get-timeline-data= :: Grouped by print_filename, packets grouped by packet-msg, sorted by device-time-us
- =get-telemetry-packets= :: Packets grouped by sender/wall-time-str, limited count

Note: Timeline data uses cached atom that updates only when :telemetry-events changes.

**** Persistence

- =save-state-to-storage!= :: Saves UI preferences to localStorage (debounced, 1 second)
- =load-state-from-storage!= :: Loads UI preferences from localStorage on init
- Persisted keys: =:selected-time, :selected-filename, :view-mode=
- Note: =:telemetry-events= are NOT persisted (must be loaded from server files)
- Note: =:selected-time= is legacy/unused; timeline uses =:selected-packet-msg= instead

*** aeonik.events

Event dispatch and state transformations.

**** Event Types

- =:connection/open= :: WebSocket connected
- =:connection/close= :: WebSocket disconnected
- =:ws/message= :: WebSocket message received
- =:view/set= :: Set view mode
- =:view/set-cycle= :: Cycle through view modes
- =:pause/toggle= :: Toggle pause state (legacy/unused)
- =:data/clear= :: Clear all telemetry events
- =:data/load-file= :: Load telemetry packets from file
- =:timeline/set-filename= :: Set selected print filename
- =:timeline/set-packet-msg= :: Set selected packet msg number for scrubbing
- =:timeline/play= :: Start timeline playback
- =:timeline/stop= :: Stop timeline playback
- =:timeline/tick= :: Timeline playback tick (steps by packet msg)
- =:timeline/step-forward= :: Step forward 1 packet
- =:timeline/step-backward= :: Step backward 1 packet
- =:timeline/jump-to-start= :: Jump to start of timeline (min packet msg)
- =:timeline/jump-to-end= :: Jump to end of timeline (max packet msg)
- =:files/set-available= :: Set available telemetry files list
- =:files/fetch-available= :: Trigger fetch of available files (side effect)

**** Key Functions

- =dispatch!= :: Main event dispatcher (updates app-state atom)
- =handle-event= :: Pure function for state transformations
- =handle-ws-message= :: Processes WebSocket messages
  - Creates event records (one per metric)
  - Appends to :telemetry-events (maintains sort order using merge-sorted-events)
  - Ensures timeline selection is set
- =create-events= :: Creates event records from metrics (includes packet-msg, received-at)
- =ensure-timeline-selection= :: Sets default timeline selection if missing
- =load-telemetry-packets= :: Loads packets from file (processes in batches for large files)
- =packets-to-events= :: Converts packets to event records
- =merge-sorted-events= :: Efficiently merges two sorted event vectors (O(n+m))

*** aeonik.ws

WebSocket connection management.

**** Key Functions

- =connect-websocket!= :: Establishes WebSocket connection
  - Uses relative URL (/ws) - shadow-cljs proxies to backend automatically
  - Sets up event handlers (onopen, onclose, onerror, onmessage)
  - Stores socket in app-state :ws (not persisted)
- =parse-ws-message= :: Parses JSON message from server
  - Extracts sender, metrics, wall-time-str, prelude, received-at
  - Extracts print_filename from metrics
  - Converts to Clojure data structures
  - Returns event map with :type :ws/message

*** aeonik.views

View rendering functions (Reagent components).

**** Views

- =status-view= :: Connection status indicator
- =latest-view= :: Latest values table (derived from :telemetry-events)
- =packets-view= :: Recent packets list (derived from :telemetry-events)
- =timeline-view= :: Timeline scrubbing interface (derived from :telemetry-events)

*** aeonik.timeline

Timeline playback loop management.

**** Key Functions

- =set-dispatch-callback!= :: Sets callback for timeline events (called from events namespace)
- =start-loop!= :: Starts playback loop (100ms interval, steps by packet msg)
- =stop-loop!= :: Stops playback loop
- =update-loop!= :: Updates loop based on state changes
- =compute-packet-range= :: Computes min/max packet msg numbers from timeline data

**** State Watcher

Watches =app-state= for changes to:
- =:timeline-playing=
- =:selected-filename=
- =:telemetry-events=

Automatically starts/stops loop based on state. Loop dispatches =:timeline/tick= events.

*** aeonik.util

Utility functions for formatting and parsing.

**** Key Functions

- =format-metric-value= :: Formats metric values for display
- =format-time= :: Formats device time (MM:SS.mmm)
- =parse-wall-time-str= :: Parses wall-time string (HH:mm:ss.SSS) to milliseconds
- =format-wall-time-ms= :: Formats milliseconds to wall-time string
- =get-metrics-at-packet= :: Gets metrics at selected packet msg number
- =pad-number= :: Pads number with leading zeros

*** aeonik.files

File loading and management.

**** Key Functions

- =fetch-available-files!= :: Fetches list of available telemetry files from server
- =load-telemetry-file= :: Loads telemetry file from server and dispatches :data/load-file event
- =get-api-base-url= :: Gets base URL for API calls (uses relative URLs)

Note: aeonik.render namespace does not exist. Rendering is handled directly by Reagent components in aeonik.views.

* Data Structures

** Telemetry Packet (Backend)

#+BEGIN_SRC clojure
{:sender          <socket-address>    ; UDP sender address
 :received-at     <java.util.Date>    ; Server receive time
 :prelude         {:msg <int>         ; Message number
                   :tm <int>          ; Base time (microseconds)
                   :v <int>}         ; Version
 :metrics         [{:name "metric_name"
                    :type :numeric | :error | :structured
                    :value <value>    ; For numeric
                    :error <string>   ; For error
                    :fields <map>     ; For structured
                    :tick <int>       ; Tick offset
                    :device-time-us <int>  ; Calculated time
                    :device-time-str "MM:SS.mmm"}]
 :wall-time-str   "HH:mm:ss.SSS"     ; Formatted wall time
 :display-lines   ["formatted line"] ; For console display
 :raw             <string>}           ; Original packet text
#+END_SRC

** Telemetry Event (Frontend)

#+BEGIN_SRC clojure
{:sender          <string>            ; Sender address as string
 :name            <string>            ; Metric name
 :value           <any>              ; Metric value
 :fields          <map>              ; Structured fields
 :error           <string>           ; Error message
 :type            <keyword>           ; :numeric | :error | :structured
 :tick            <int>              ; Tick offset (from metric)
 :device-time-us  <int>              ; Device time (microseconds)
 :device-time-str "MM:SS.mmm"        ; Formatted device time
 :wall-time-str   "HH:mm:ss.SSS"     ; Wall time string
 :wall-time-ms    <int>              ; Wall time (milliseconds since midnight)
 :packet-msg      <int>              ; Packet message number (for timeline navigation)
 :received-at     <long>             ; Timestamp when packet was received (ms)
 :print-filename  <string>}          ; Associated print filename
#+END_SRC

** JSON Packet (WebSocket)

#+BEGIN_SRC clojure
{:sender        <string>
 :received-at   <long>              ; Timestamp (milliseconds)
 :prelude       {:msg <int> :tm <int> :v <int>}
 :metrics       [{:name <string>
                  :type <string>   ; "numeric" | "error" | "structured"
                  :offset-ms <int> ; Tick offset in milliseconds
                  :tick-ms <int>   ; Compatibility alias (same as offset-ms)
                  :device-time-us <int>
                  :device-time-str <string>
                  :value <any>      ; Optional (for numeric type)
                  :error <string>   ; Optional (for error type)
                  :fields <map>}    ; Optional (for structured type)
 :display-lines [<string>]          ; Formatted display lines
 :wall-time-str <string>}           ; Formatted wall time
#+END_SRC

* Key Concepts

** Single Source of Truth

The frontend uses a single =:telemetry-events= vector as the source of truth. All views are derived from this vector using pure functions:
- =get-latest-values= :: Groups by sender/name, takes latest (sorted by device-time-us)
- =get-timeline-data= :: Groups by print_filename, then by packet-msg, sorts events by device-time-us
- =get-telemetry-packets= :: Groups by sender/wall-time-str, limits count

Timeline data is cached in an atom that updates only when :telemetry-events changes.

** Stream Processing

Backend uses Manifold streams for asynchronous processing:
- Multiple consumers can attach to a stream
- Transducers provide efficient transformations
- Single consumer for file saving prevents duplicates
- Each WebSocket client gets its own consumer

** Print Lifecycle Tracking

The backend tracks active prints using a "sticky" mechanism:
- When =print_filename= is detected, it becomes the active print
- Active print persists across packets (even without =print_filename=)
- Print ends after 10 minutes of inactivity
- Each sender (printer) has independent print tracking

** State Persistence

Frontend persists UI preferences to localStorage:
- Debounced saves (1 second delay)
- Only persists: =:selected-time=, =:selected-filename=, =:view-mode=
- =:telemetry-events= are NOT persisted (must reload from server files)
- Automatically loads UI preferences on page refresh
- Large files are loaded in batches (100 packets) to avoid blocking UI

** Timeline Playback

Timeline playback uses a JavaScript interval:
- 100ms steps (10 updates per second)
- Steps by packet msg number (not time-based)
- Automatically starts/stops based on state
- Stops when user interacts with slider
- Watches state changes to update loop
- Computes packet range (min/max msg) from timeline data

* File Structure

** Backend Files

- =src/aeonik/prusa_telemetry.clj= :: UDP server, parsing, transducers
- =src/aeonik/web_server.clj= :: HTTP/WebSocket server, file persistence
- =dev/user.clj= :: REPL utilities, service management

** Frontend Files

- =src-cljs/aeonik/app.cljs= :: Application entry point
- =src-cljs/aeonik/state.cljs= :: State management, persistence
- =src-cljs/aeonik/events.cljs= :: Event dispatch, handlers
- =src-cljs/aeonik/ws.cljs= :: WebSocket connection
- =src-cljs/aeonik/views.cljs= :: View rendering (Reagent components)
- =src-cljs/aeonik/timeline.cljs= :: Timeline playback loop
- =src-cljs/aeonik/util.cljs= :: Utility functions
- =src-cljs/aeonik/files.cljs= :: File loading and management

** Configuration Files

- =shadow-cljs.edn= :: ClojureScript build configuration
- =deps.edn= :: Dependency management
- =build.clj= :: Build scripts

** Data Files

- =telemetry-data/prints/YYYY-MM-DD/<filename>.edn= :: Persisted telemetry (append-only EDN)

* Development Workflow

** Starting Services

#+BEGIN_SRC clojure
;; In REPL (dev/user.clj auto-starts on REPL connection)
(user/start!)                    ; Start all services
(user/start-telemetry!)          ; Start telemetry server only
(user/start-telemetry! {:port 8514 :processed-buffer-size 500000})  ; Custom buffer size
(user/start-web!)                ; Start web server only
(user/restart!)                   ; Restart all services
(user/status)                     ; Check service status
#+END_SRC

** Accessing the Application

- Development: =http://localhost:9630= (shadow-cljs dev server with REPL)
  - Shadow-cljs serves HTML/JS files and proxies all requests (including /ws and /api/*) to backend on port 8080
  - Frontend uses relative URLs - no port detection needed
- Production: =http://localhost:8080= (direct web server)

** Hot Reloading

- ClojureScript: Automatic via shadow-cljs watch
- Clojure: Manual reload via REPL (restart services after reload)

** Common Issues

- Data flow stops after reload: Restart web server (=user/restart!=)
- Duplicate file writes: Fixed by single consumer pattern
- State not persisting: Check localStorage size limit (4MB)

* Buffer Configuration

** Manifold Stream Buffers

Most Manifold streams use 100-item buffers to handle backpressure:

- =parsed-stream= :: 100 items (raw parsed packets)
- =processed-stream= :: 200,000 items (after transducer pipeline, configurable via :processed-buffer-size)
  - Large default to handle days-long prints before archiving
  - Can be configured when starting telemetry server
- =metric-stream= :: 100 items (unwrapped, time-ordered metrics)
- =subscription-stream= :: 100 items (per metric-stream consumer)
- =client-stream= :: 100 items (per WebSocket client)
- =saving-stream= :: 100 items (for packet file persistence)
- =tap-parsed= :: 100 items (for REPL inspection)
- =tap-processed= :: 100 items (for REPL inspection)

** In-Memory Inspection Buffers

REPL inspection buffers (in =dev/user.clj=) maintain recent data:

- =packet-buffer-parsed= :: Max 100 packets (drops oldest when full)
- =packet-buffer-processed= :: Max 100 packets (drops oldest when full)
- =metric-buffer= :: Max 100 metrics (drops oldest when full)
- =packet-registry= :: Unbounded (maps packet-id to packet metadata)

** Metric Stream Packet Buffer

The metric stream uses a packet buffer for time-ordering:

- =packet-buffer= :: Default 2 packets (configurable)
  - Allows temporary growth beyond buffer-size
  - Only drops packets when emitting (never on insert)
  - Handles metrics with negative time offsets

** Buffer Size Summary

- **Stream buffers**: 
  - Most streams: 100 items each
  - processed-stream: 200,000 items (default, configurable via :processed-buffer-size)
  - Total: ~200,800 items capacity (dominated by processed-stream)
- **Inspection buffers**: 100 items each (3 buffers = 300 total capacity)
- **Packet registry**: Unbounded (grows with unique packets)
- **Metric stream packet buffer**: 2 packets (default, configurable)

Note: The processed-stream buffer is intentionally large to handle days-long prints. 
At ~2 seconds per packet, 200,000 items can buffer ~4.6 days of continuous printing.

* Performance Considerations

** Backend

- Stream buffering: 
  - Most streams: 100-item buffers
  - processed-stream: 200,000-item buffer (configurable, default handles days-long prints)
- Transducer pipeline: Efficient, lazy transformations
- Single file consumer: Prevents duplicate writes
- Print tracking: In-memory atom (fast lookups)
- Packet inspection: Limited to 100 items per buffer (prevents unbounded growth)
- Large processed buffer: Prevents packet loss during slow archiving or high packet rates

** Frontend

- Derived views: Computed on-demand (timeline data cached in atom)
- State persistence: Debounced to avoid excessive writes (UI preferences only)
- Timeline playback: 100ms interval (10 FPS, steps by packet msg)
- Event merging: Maintains sorted order using O(n+m) merge (merge-sorted-events)
- File loading: Batched processing (100 packets) to avoid blocking UI
- Timeline data: Cached atom updates only when :telemetry-events changes

** Scalability

- Multiple WebSocket clients: Each gets own consumer (scales linearly)
- File persistence: Append-only writes (efficient)
- State persistence: Only UI preferences stored (small, fast)
- Event count: No hard limit in memory (limited by browser memory)
- File loading: Batched processing prevents UI blocking for large files

* Future Improvements

** Potential Enhancements

- Add metrics aggregation/statistics
- Implement data compression for localStorage
- Add export/import functionality for telemetry data
- Support multiple printers with separate tracking
- Add real-time charts/graphs
- Implement data filtering/search
- Add print comparison features
- Support for historical data queries
